#pragma once

#include <functional>
#include <numeric>
#include <string>
#include <filesystem>

#include <wrong/flags>
#include <wrong/remote>
#include <wrong/builder>
#include <wrong/package>

namespace wrong {

class dependency final
{
	friend class package;

public:
	/*! Cannot create an empty dependency.
	 */
	dependency () = delete;

	/*! Create a new dependency with the given name.
	 */
	dependency (std::string name)
		: _name(name), _remote(std::make_unique<remote::none>()), _builder(std::make_unique<builder::none>())
	{ }

protected:
	/*! Specialize the dependency.
	 */
	template <typename Remote, typename Builder>
	dependency (std::string name, std::unique_ptr<Remote> remote, std::unique_ptr<Builder> builder)
		: _name(name), _remote(std::move(remote)), _builder(std::move(builder))
	{ }

public:
	class flags const&
	flags () const
	{
		return _flags;
	}

	/*! The dependency is a system package.
	 */
	dependency&
	package ()
	{
		class package pkg;
		pkg.name(_name);
		_package = pkg;
		return *this;
	}

	dependency&
	package (std::function<void(class package&)> setup)
	{
		class package pkg;
		setup(pkg);
		_package = pkg;
		return *this;
	}

	/*! Set the remote to use for this dependency, automatically creating it.
	 */
	template <typename Remote, typename... Args>
	dependency&
	remote (Args... args, std::function<void(Remote&)> setup)
	{
		auto remote = std::make_unique<Remote>(std::forward<Args>(args)...);
		setup(*remote);

		_remote = std::move(remote);
		return *this;
	}

	/*! Set the remote to use for this dependency.
	 */
	template <typename Remote, typename... Args>
	dependency&
	remote (std::unique_ptr<Remote> remote)
	{
		_remote = remote;
		return *this;
	}

	/*! Set the builder to use for this dependency, automatically creating it.
	 */
	template <typename Builder, typename... Args>
	dependency&
	builder (Args... args, std::function<void(Builder&)> setup)
	{
		auto builder = std::make_unique<Builder>(std::forward<Args>(args)...);
		setup(*builder);

		_builder = std::move(builder);
		return *this;
	}

	/*! Set the builder to use for this dependency.
	 */
	template <typename Builder, typename... Args>
	dependency&
	builder (std::unique_ptr<Builder> builder)
	{
		_builder = builder;
		return *this;
	}

	/*! Define the dependency as a path dependency.
	 */
	dependency&
	path (std::filesystem::path path)
	{
		_path = path;
		return *this;
	}

	/*! Fetch and build the dependency.
	 */
	int
	build ()
	{
		if (_package) {
			if (auto result = _package->apply(_flags); result != 0) {
				return result;
			}
		}

		if (auto result = _remote->fetch(); result != 0) {
			return result;
		}

		if (auto result = _builder->build(_remote->path() / _path); result != 0) {
			return result;
		}

		return 0;
	}

private:
	/*! The name of the dependency.
	 */
	std::string _name;

	/*! The path within the remote where the dependency resides.
	 */
	std::filesystem::path _path;

	/*! Flags to pass to the compiler.
	 */
	class flags _flags;

	/*! Package definition, if present.
	 */
	std::optional<class package> _package;

	/*! The internal remote handler.
	 */
	std::unique_ptr<remote::base> _remote;

	/*! The internal builder handler.
	 */
	std::unique_ptr<builder::base> _builder;
};

}
