#pragma once

#include <future>
#include <string>
#include <memory>
#include <unordered_map>

#include <wrong/place>
#include <wrong/provision>
#include <wrong/action>

namespace wrong {

/*! A dependency which provides provisions.
 */
class dependency
{
public:
	/*! A provision that can be built.
	 */
	class provision
	{
	public:
		using type = std::variant<asset, library, program>;

	public:
		template <typename Action>
		provision (std::string name, Action action)
			: _name(name)
		{
			struct variant : public action::base<typename action::traits<Action>::output, type>
			{
				type
				run (typename action::traits<Action>::output output)
				{
					return output;
				}
			};

			_action = action::as_ptr(action >> variant());
		}

		/*! Get the name of the provision.
		 */
		std::string_view
		name () const
		{
			return _name;
		}

		/*! Get a future that will resolve to the built provision.
		 */
		std::future<type>
		get_future ()
		{
			return std::async(std::launch::async, [this]() {
				return _action->run(action::nothing());
			});
		}

	private:
		/*! The name being provided.
		 */
		std::string _name;

		/*! The action to build the provision.
		 */
		std::unique_ptr<action::base<action::nothing, type>> _action;
	};

public:
	dependency (std::string name)
		: _name(name), _place(std::make_unique<class place::none>())
	{ }

	/*! Define where the dependency can be found.
	 */
	template <typename Builder>
	dependency&
	place (Builder& place)
	{
		_place = std::make_unique<typename Builder::place>(place);
		return *this;
	}

	/*! Define a provision that the dependency provides.
	 */
	template <typename Provision, typename Action>
	dependency&
	provides (std::string name, Action action)
	{
		static_assert(std::is_same<typename action::traits<Action>::output, Provision>::value,
			"The action does not return the right type of provision");

		provision provided(name, action);
		_provisions.insert({ std::move(name), std::move(provided) });

		return *this;
	}

	provision&
	provided (std::string name)
	{
		return _provisions.at(name);
	}

private:
	/*! The name of the dependency.
	 */
	std::string _name;

	/*! The place where the dependency is.
	 */
	std::unique_ptr<place::base> _place;

	/*! The provisions provided by this dependency.
	 */
	std::unordered_map<std::string, provision> _provisions;
};

}
