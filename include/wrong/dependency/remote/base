#pragma once

#include <filesystem>
#include <optional>
#include <functional>

#include <wrong/util>
#include <wrong/dependency/base>
#include <wrong/builder/base>

namespace wrong { namespace dependency { namespace remote {

template <typename Self, typename Builder>
class base : public virtual dependency::base
{
public:
	using dependency::base::base;

	// Without a virtual constructor the children won't be properly destroyed.
	virtual ~base () { }

	/*! The absolute path to the fetched remote.
	 */
	virtual std::filesystem::path path () const = 0;

	/*! Fetch the remote.
	 */
	virtual int fetch () = 0;

public:
	std::optional<std::filesystem::path>
	root () const
	{
		return _root;
	}

	Self&
	root (std::filesystem::path value)
	{
		_root = value;
		return static_cast<Self&>(*this);
	}

	template <typename Builder>
	Self&
	builder (std::function<void(Builder&)> setup)
	{
		std::unique_ptr<Builder> builder;
		setup(*builder);
//		_builder = std::make_optional(builder);

		return dynamic_cast<Self&>(*this);
	}

	int
	use (flags& flags)
	{
		WRONG_TRY(fetch());

		if (_builder) {
			auto root = path();

			if (_root) {
				root /= _root.value();
			}

			WRONG_TRY(_builder.value()->build(root));
			WRONG_TRY(_builder.value()->use(root, flags));
		}

		return 0;
	}

private:
	std::optional<std::filesystem::path> _root;
	std::optional<std::unique_ptr<builder::base>> _builder;
};

} } }
