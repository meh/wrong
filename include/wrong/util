#pragma once

#include <cstdio>
#include <iostream>
#include <memory>
#include <stdexcept>
#include <string>
#include <array>
#include <functional>
#include <sstream>

namespace wrong { namespace util {

#define WRONG_TRY(body) \
	if (int result = (body); result != 0) { \
		return result; \
	}

struct process
{
	std::string stdout;
	int status;
};

static inline
process
shell (std::string cmd) {
	std::array<char, 129> buffer;
	std::ostringstream stdout;
	std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd.c_str(), "r"), pclose);

	if (!pipe) {
		throw std::runtime_error("popen() failed!");
	}

	// Read as much output as possible.
	size_t consumed = 0;
	do {
		std::fill_n(buffer.data(), buffer.size(), 0);
		consumed = std::fread(buffer.data(), 1, buffer.size() - 1, pipe.get());
		stdout << buffer.data();
	} while (consumed == buffer.size() - 1);

	// Wait for the process to exit and save the status code.
	auto status = WEXITSTATUS(pclose(pipe.get()));

	return { .stdout = stdout.str(), .status = status };
}

static inline
process
shell (std::function<void(std::ostream&)> cmd) {
	std::ostringstream out;
	cmd(out);
	return shell(out.str());
}

/*! Trim from the start (in place).
 */
static inline
void
ltrim (std::string& s)
{
	s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {
		return !std::isspace(ch);
	}));
}

/*! Trim from the end (in place).
 */
static inline
void
rtrim(std::string& s)
{
	s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {
		return !std::isspace(ch);
	}).base(), s.end());
}

/*! Trim (in place).
 */
static inline
void
trim (std::string& s)
{
	ltrim(s);
	rtrim(s);
}

} }
