#pragma once

#include <functional>
#include <algorithm>
#include <array>
#include <numeric>
#include <tuple>

#include <wrong/provision>
#include <wrong/file_list>
#include <wrong/compiler>

namespace wrong { namespace action {

/*! Base class that any action must define.
 */
template <typename In, typename Out>
struct base
{
	using in = In;
	using out = Out;

	virtual Out run (In input) = 0;
	virtual ~base () { }
};

/*! Check whether a type is a valid action or not.
 */
template <typename Self, typename = void>
struct is_action : std::false_type
{ };

template <typename Self>
struct is_action<Self, std::enable_if_t<
	std::is_base_of<base<typename Self::in, typename Self::out>, Self>::value>>
: std::true_type
{ };


/*! Traits every action must define.
 */
template <typename Self, typename = void>
struct traits
{ };

template <typename Self>
struct traits<Self, std::enable_if_t<is_action<Self>::value>>
{
	/*! The input type.
	 */
	using in = typename Self::in;

	/*! The output type.
	 */
	using out = typename Self::out;
};

template <typename Left, typename Right, typename = void>
struct is_bindable : std::false_type
{ };

template <typename Left, typename Right>
struct is_bindable<Left, Right, std::enable_if_t<
	std::is_same<typename traits<Left>::out, typename traits<Right>::in>::value>>
: std::true_type
{ };

/*! Nothing of value.
 */
struct nothing
{
	nothing ()
	{ }

	template <typename In>
	nothing (In _input)
	{ }
};

/*! Turn a value into an action.
 */
template <typename Value>
class unit final : public virtual base<nothing, Value>
{
public:
	unit (Value value)
		: _value(value)
	{ }

	Value
	run (nothing _)
	{
		return _value;
	}

private:
	Value _value;
};

/*! Trick to put an action into a pointer.
 */
template <typename Action>
class identity final : public virtual base<typename traits<Action>::in, typename traits<Action>::out>
{
public:
	identity (Action action)
		: _action(action)
	{ }

	typename traits<Action>::out
	run (typename traits<Action>::in input)
	{
		return _action.run(input);
	}

private:
	Action _action;
};

/*! Turn a function into an action.
 *
 * What this allows is to turn a normal function into an action, making it
 * usable within the rest of the system.
 */
template <typename In, typename Out>
class function final : public virtual base<In, Out>
{
public:
	function (std::function<Out(In)> fun)
		: _fun(fun)
	{ }

	Out
	run (In input)
	{
		return _fun(input);
	}

private:
	std::function<Out(In)> _fun;
};

/*! Allows composition of actions.
 *
 * It's essentially function composition, actions are chained together to form
 * an action that takes the input of the first action and returns the output of
 * the last, piping input to output of each action.
 *
 * Composition is one of the most important concepts involved in the action
 * system, it's what actually makes it flexible, and as you might have guessed,
 * composable.
 *
 * # Example
 *
 * In this example actions are composed to compile some sources into an
 * executable.
 *
 * ```cpp
 * sources({ "source/{a,b,c}.cpp" })
 * >> compile()
 * >> executable()
 * ```
 *
 * * First `sources` takes `nothing` as input and reurns a `files` as output.
 * * Then `compile` takes `files` as input and returns `files` as output.
 * * And finally `executable` takes `files` as input and returns a `program`
 *   provision.
 */
template <typename Head, typename... Tail>
class bind final : public virtual base<typename traits<Head>::in, typename traits<nth<sizeof...(Tail) - 1, Tail...>>::out>
{
	static_assert(sizeof...(Tail) >= 1, "unary bind makes no sense");
	// TODO(meh): Figure out how to use is_bindable on Head, Tail... and assert
	//            on it

public:
	bind (Head head, Tail... tail)
		: _actions({ head, tail... })
	{ }

	typename traits<nth<sizeof...(Tail) - 1, Tail...>>::out
	run (typename traits<Head>::in input)
	{
		return _run<typename traits<nth<sizeof...(Tail) - 1, Tail...>>::out,
			0, Head, Tail...>(input);
	}

	std::tuple<Head, Tail...>&
	actions ()
	{
		return _actions;
	}

private:
	template <typename Out, size_t I, typename First>
	Out
	_run (typename traits<First>::in input)
	{
		return std::get<I>(_actions).run(input);
	}

	template <typename Out, size_t I, typename First, typename Second, typename... Rest>
	Out
	_run (typename traits<First>::in input)
	{
		return _run<Out, I + 1, Second, Rest...>(std::get<I>(_actions).run(input));
	}

private:
	std::tuple<Head, Tail...> _actions;
};

/*! Allows reducing the output of multiple actions into one.
 */
template <typename BinaryOp, typename Head, typename... Tail>
class reduction final : public virtual base<typename traits<Head>::in, typename traits<Head>::out>
{
	static_assert(is_all_true<std::is_same<typename traits<Head>::in, typename traits<Tail>::in>::value...>::value,
		"cannot reduce actions of different input type");

	static_assert(is_all_true<std::is_same<typename traits<Head>::out, typename traits<Tail>::out>::value...>::value,
		"cannot reduce actions of different output type");

public:
	reduction (BinaryOp op, Head head, Tail... tail)
		: _op(op), _actions({ head, tail... })
	{ }

	typename traits<Head>::out
	run (typename traits<Head>::in input)
	{
		return run(input, std::index_sequence_for<Tail...>{});
	}

private:
	template <size_t... I>
	typename traits<Head>::out
	run (typename traits<Head>::in input, std::index_sequence<I...>)
	{
		std::vector<typename traits<Head>::out> output;
		output.push_back(std::get<0>(_actions).run(input));
		(output.push_back(std::get<I + 1>(_actions).run(input)), ...);

		// TODO(meh): Implement this with std::reduce, or our own version of it.
		return std::accumulate(output.begin() + 1, output.end(), output[0], _op);
	}

private:
	BinaryOp _op;
	std::tuple<Head, Tail...> _actions;
};

/*! Helper to create compose from a tuple.
 */
template <template <typename...> class Operator, typename... Action, size_t... Indices>
Operator<Action...>
op (std::tuple<Action...> actions, std::index_sequence<Indices...>)
{
	return { std::get<Indices>(actions)... };
}

template <template <typename...> class Operator, typename... Action>
Operator<Action...>
op (std::tuple<Action...> actions)
{
	return op<Operator>(actions, std::index_sequence_for<Action...>{});
}

template <template <typename, typename...> class Operator, typename BinaryOp, typename... Action, size_t... Indices>
Operator<BinaryOp, Action...>
op (BinaryOp bop, std::tuple<Action...> actions, std::index_sequence<Indices...>)
{
	return { bop, std::get<Indices>(actions)... };
}

template <template <typename, typename...> class Operator, typename BinaryOp, typename... Action>
Operator<BinaryOp, Action...>
op (BinaryOp bop, std::tuple<Action...> actions)
{
	return op<Operator>(bop, actions, std::index_sequence_for<Action...>{});
}

/*! Helper to compose actions.
 */
template <typename... Left, typename... Right>
bind<Left..., Right...>
operator>> (bind<Left...> left, bind<Right...> right)
{
	return op<bind>(std::tuple_cat(left.actions(), right.actions()));
}

template <typename... Left, typename Right>
bind<Left..., Right>
operator>> (bind<Left...> left, Right right)
{
	return op<bind>(std::tuple_cat(left.actions(), std::make_tuple(right)));
}

template <typename Left, typename... Right>
bind<Left, Right...>
operator>> (Left left, bind<Right...> right)
{
	return op<bind>(std::tuple_cat(std::make_tuple(left), right));
}

template <typename Left, typename Right, typename = std::enable_if_t<is_action<Left>::value && is_action<Right>::value>>
bind<Left, Right>
operator>> (Left left, Right right)
{
	return { left, right };
}

template <typename... Left, typename... Right>
bind<Right..., Left...>
operator<< (bind<Left...> left, bind<Right...> right)
{
	return op<bind>(std::tuple_cat(right.actions(), left.actions()));
}

template <typename... Left, typename Right>
bind<Right, Left...>
operator<< (bind<Left...> left, Right right)
{
	return op<bind>(std::tuple_cat(std::make_tuple(right), left.actions()));
}

template <typename Left, typename... Right>
bind<Right..., Left>
operator<< (Left left, bind<Right...> right)
{
	return op<bind>(std::tuple_cat(right, std::make_tuple(left)));
}

template <typename Left, typename Right, typename = std::enable_if_t<is_action<Left>::value && is_action<Right>::value>>
bind<Right, Left>
operator<< (Left left, Right right)
{
	return { right, left };
}

/*! Helper to unify action results.
 */
template <typename BinaryOp, typename... Left, typename... Right>
auto
operator+ (reduction<BinaryOp, Left...> left, reduction<BinaryOp, Right...> right)
{
	return op<reduction>(union_of<typename traits<nth<0, Left...>>::out>(),
		std::tuple_cat(left.actions(), right.actions()));
}

template <typename... Left, typename Right>
auto
operator+ (reduction<Left...> left, Right right)
{
	return op<reduction>(union_of<typename traits<Right>::out>(),
		std::tuple_cat(left.actions(), std::make_tuple(right)));
}

template <typename Left, typename... Right>
auto
operator+ (Left left, reduction<Right...> right)
{
	return op<reduction>(union_of<typename traits<Left>::out>(),
		std::tuple_cat(std::make_tuple(left), right));
}

template <typename Left, typename Right, typename = std::enable_if_t<is_action<Left>::value && is_action<Right>::value>>
auto
operator+ (Left left, Right right)
{
	return op<reduction>(union_of<typename traits<Left>::out>(),
		std::make_tuple(left, right));
}

template <typename BinaryOp, typename... Actions>
auto
reduce (BinaryOp bop, Actions... actions)
{
	return op<reduction>(bop, std::make_tuple(actions...));
}

/*! Turn a value into an action.
 */
template <typename Value>
unit<Value>
value (Value value)
{
	return value;
}

/*! Helper to create an std::unique_ptr out of any action.
 */
template <typename Action>
std::unique_ptr<action::base<typename traits<Action>::in, typename traits<Action>::out>>
as_ptr (Action action)
{
	return std::make_unique<identity<Action>>(action);
}

/*! Create an action out of any function.
 */
template <typename In, typename Out>
function<In, Out>
then (std::function<Out(In)> fun)
{
	return { fun };
}

struct source;
struct header;
struct object;

/*! List of required provisions.
 */
class requirements
{
public:
	struct spec
	{
		std::string path;
	};

private:
	template <typename Action, typename = void>
	struct use_if_available
	{
		use_if_available (std::string _path)
		{ }

		void
		apply (Action action)
		{ }
	};

	template <typename Action>
	struct use_if_available<Action, std::enable_if_t<&Action::use>>
	{
		use_if_available (std::string path)
			: _path(path)
		{ }

		void
		apply (Action action)
		{
			action.use(_path);
		}

	private:
		std::string _path;
	};

public:
	explicit
	requirements (std::vector<spec> specs = {})
		: _specs(specs)
	{ }

	template <typename Type>
	void
	use (std::string path)
	{
		_specs.push_back({
			.path = path,
		});
	}

	template <typename Action, typename = std::enable_if_t<is_action<Action>::value>>
	void
	apply (Action action)
	{
		for (auto& spec : _specs) {
			action.template apply<use_if_available>(spec.path);
		}
	}

	requirements
	operator+ (requirements const& other)
	{
		requirements result(_specs);
		result._specs.insert(result._specs.end(), other._specs.begin(), other._specs.end());
		return result;
	}

private:
	std::vector<spec> _specs;
};

/*! An action that takes a list of files (source files) and produces a list of
 *  files (object files).
 *
 * In this step the input files are checked to be up-to-date with the output
 * files, and compilation is skipped if not needed.
 */
class compile final : public virtual base<file_list<source>, file_list<object>>
{
public:
	compile (std::shared_ptr<compiler::base> compiler)
		: _compiler(compiler)
	{ }

public:
	file_list<object>
	run (file_list<source> input)
	{
		return {};
	}

	/*! Add a path to the include paths.
	 */
	compile
	include (std::string value)
	{
		_compiler->include(value);
		return *this;
	}

	/*! Add a definition.
	 */
	compile
	define (std::string name, std::string value)
	{
		_compiler->define(name, value);
		return *this;
	}

	/*! Enable a definition.
	 */
	compile
	define (std::string name)
	{
		_compiler->define(name);
		return *this;
	}

	compile
	language (compiler::language::specification&& spec)
	{
		_compiler->language(spec);
		return *this;
	}

private:
	std::shared_ptr<compiler::base> _compiler;
};

/*! An action that takes a list of files (object files) and produces a program.
 *
 * This is the final linking step that produces a valid provision.
 */
class executable final : public virtual base<file_list<object>, program>
{
public:
	program
	run (file_list<object> input)
	{
		// TODO(meh): implement this
		return { "" };
	}

	/*! Add a path to the library paths.
	 */
	executable
	include (std::string value)
	{
		_flags.push_back("-L" + value);
		return *this;
	}

	/*! Add a library to be linked.
	 */
	executable
	link (std::string name)
	{
		_flags.push_back("-l" + name);
		return *this;
	}

	/*! Add a library to be linked.
	 */
	executable
	use (std::string path)
	{
		// TODO(meh): actually link it
		return *this;
	}

private:
	std::vector<std::string> _flags;
};

/*! An action that takes a list of files (object files) and produces a shared
 *  library.
 *
 * This is the final linking step that produces a valid provision.
 */
class shared final : public virtual base<file_list<object>, library>
{
public:
	library
	run (file_list<object> input)
	{
		// TODO(meh): implement this
		return { false, {}, {} };
	}

	/*! Add a path to the library paths.
	 */
	shared
	include (std::string value)
	{
		_flags.push_back("-L" + value);
		return *this;
	}

	/*! Add a library to be linked.
	 */
	shared
	link (std::string name)
	{
		_flags.push_back("-l" + name);
		return *this;
	}

	/*! Add a library to be linked.
	 */
	shared
	use (std::string path)
	{
		// TODO(meh): actually link it
		return *this;
	}

private:
	std::vector<std::string> _flags;
};

/*! An action that takes a list of files (object files) and produces a static
 *  archive.
 *
 * This is the final linking step that produces a valid provision.
 */
class archive final : public virtual base<file_list<object>, library>
{
public:
	library
	run (file_list<object> input)
	{
		// TODO(meh): implement this
		return { true, {}, {} };
	}
};

template <typename Type>
requirements
use (std::string path)
{
	requirements r;
	r.use<Type>(path);

	return r;
}

auto
sources (file_list<source> input)
{
	return value(input);
}

auto
headers (file_list<header> input)
{
	return value(input);
}

auto
objects (file_list<object> input)
{
	return value(input);
}

template <typename Compiler = compiler::gcc>
class compile
compile ()
{
	return { std::make_shared<Compiler>() };
}

class executable
executable ()
{
	return {};
}

class shared
shared ()
{
	return {};
}

class archive
archive ()
{
	return {};
}

} }
