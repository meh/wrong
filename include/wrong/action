#pragma once

#include <functional>
#include <algorithm>
#include <array>
#include <numeric>

#include <wrong/provision>
#include <wrong/files>
#include <wrong/compiler>

namespace wrong { namespace action {

/*! Base class that any action must define.
 */
template <typename Input, typename Output>
struct base
{
	using input = Input;
	using output = Output;

	virtual Output run (Input input) = 0;
	virtual ~base () { }
};

/*! Check whether a type is a valid action or not.
 */
template <typename Self, typename = void>
struct is_action : std::false_type
{ };

template <typename Self>
struct is_action<Self, std::enable_if_t<
	std::is_base_of<base<typename Self::input, typename Self::output>, Self>::value>>
: std::true_type
{ };

/*! Traits every action must define.
 */
template <typename Self, typename = void>
struct traits
{ };

template <typename Self>
struct traits<Self, std::enable_if_t<is_action<Self>::value>>
{
	/*! The input type.
	 */
	using input = typename Self::input;

	/*! The output type.
	 */
	using output = typename Self::output;
};

/*! Nothing of value.
 */
struct nothing
{
	nothing ()
	{ }

	template <typename Input>
	nothing (Input _input)
	{ }
};

/*! An action that takes nothing and returns nothing.
 */
struct none final : public virtual base<nothing, nothing>
{
	nothing
	run (nothing input)
	{
		return {};
	}
};

/*! Trick to put an action into a pointer.
 */
template <typename Action>
class identity final
	: public virtual base<typename traits<Action>::input, typename traits<Action>::output>
{
public:
	identity (Action action)
		: _action(action)
	{ }

	typename traits<Action>::output
	run (typename traits<Action>::input input)
	{
		return _action.run(input);
	}

private:
	Action _action;
};

/*! Turn a function into an action.
 *
 * What this allows is to turn a normal function into an action, making it
 * usable within the rest of the system.
 */
template <typename Input, typename Output>
class function final : public virtual base<Input, Output>
{
public:
	function (std::function<Output(Input)> fun)
		: _fun(fun)
	{ }

	Output
	run (Input input)
	{
		return _fun(input);
	}

private:
	std::function<Output(Input)> _fun;
};

/*! Allows composition of actions.
 *
 * It's essentially function composition, actions are chained together to form
 * an action that takes the input of the first action and returns the output of
 * the last, piping input to output of each action.
 *
 * Composition is one of the most important concepts involved in the action
 * system, it's what actually makes it flexible, and as you might have guessed,
 * composable.
 *
 * # Example
 *
 * In this example actions are composed to compile some sources into an
 * executable.
 *
 * ```cpp
 * sources({ "source/{a,b,c}.cpp" })
 * >> compile()
 * >> executable()
 * ```
 *
 * * First `sources` takes `nothing` as input and reurns a `files` as output.
 * * Then `compile` takes `files` as input and returns `files` as output.
 * * And finally `executable` takes `files` as input and returns a `program`
 *   provision.
 */
template <typename Head, typename... Tail>
class composition final : public virtual base<typename traits<Head>::input, typename traits<nth<sizeof...(Tail) - 1, Tail...>>::output>
{
	static_assert(sizeof...(Tail) >= 1, "unary compose makes no sense");

public:
	composition (Head head, Tail... tail)
		: _actions({ head, tail... })
	{ }

	typename traits<nth<sizeof...(Tail) - 1, Tail...>>::output
	run (typename traits<Head>::input input)
	{
		return _run<typename traits<nth<sizeof...(Tail) - 1, Tail...>>::output,
			0, Head, Tail...>(input);
	}

	std::tuple<Head, Tail...>
	actions ()
	{
		return _actions;
	}

private:
	template <typename Output, size_t I, typename First>
	Output
	_run (typename traits<First>::input input)
	{
		return std::get<I>(_actions).run(input);
	}

	template <typename Output, size_t I, typename First, typename Second, typename... Rest>
	Output
	_run (typename traits<First>::input input)
	{
		return _run<Output, I + 1, Second, Rest...>(std::get<I>(_actions).run(input));
	}

private:
	std::tuple<Head, Tail...> _actions;
};

/*! Allows reducing the output of multiple actions into one.
 */
template <typename BinaryOp, typename Head, typename... Tail>
class reduction final : public virtual base<typename traits<Head>::input, typename traits<Head>::output>
{
	static_assert(is_all_true<std::is_same<typename traits<Head>::input, typename traits<Tail>::input>::value...>::value,
		"cannot reduce actions of different input type");

	static_assert(is_all_true<std::is_same<typename traits<Head>::output, typename traits<Tail>::output>::value...>::value,
		"cannot reduce actions of different output type");

public:
	reduction (BinaryOp op, Head head, Tail... tail)
		: _op(op), _actions({ head, tail... })
	{ }

	typename traits<Head>::output
	run (typename traits<Head>::input input)
	{
		return run(input, std::index_sequence_for<Tail...>{});
	}

	std::tuple<Head, Tail...>
	actions ()
	{
		return _actions;
	}

private:
	template <size_t... I>
	typename traits<Head>::output
	run (typename traits<Head>::input input, std::index_sequence<I...>)
	{
		std::vector<typename traits<Head>::output> output;
		output.push_back(std::get<0>(_actions).run(input));
		(output.push_back(std::get<I + 1>(_actions).run(input)), ...);

		// TODO(meh): Implement this with std::reduce, or our own version of it.
		return std::accumulate(output.begin() + 1, output.end(), output[0], _op);
	}

private:
	BinaryOp _op;
	std::tuple<Head, Tail...> _actions;
};

/*! Helper to create compose from a tuple.
 */
template <template <typename...> class Operator, typename... Action, size_t... Indices>
Operator<Action...>
op (std::tuple<Action...> actions, std::index_sequence<Indices...>)
{
	return { std::get<Indices>(actions)... };
}

template <template <typename...> class Operator, typename... Action>
Operator<Action...>
op (std::tuple<Action...> actions)
{
	return op<Operator>(actions, std::index_sequence_for<Action...>{});
}

template <template <typename, typename...> class Operator, typename BinaryOp, typename... Action, size_t... Indices>
Operator<BinaryOp, Action...>
op (BinaryOp bop, std::tuple<Action...> actions, std::index_sequence<Indices...>)
{
	return { bop, std::get<Indices>(actions)... };
}

template <template <typename, typename...> class Operator, typename BinaryOp, typename... Action>
Operator<BinaryOp, Action...>
op (BinaryOp bop, std::tuple<Action...> actions)
{
	return op<Operator>(bop, actions, std::index_sequence_for<Action...>{});
}

/*! Helper to compose actions.
 */
template <typename... Left, typename... Right>
composition<Left..., Right...>
operator>> (composition<Left...> left, composition<Right...> right)
{
	return op<composition>(std::tuple_cat(left.actions(), right.actions()));
}

template <typename... Left, typename Right>
composition<Left..., Right>
operator>> (composition<Left...> left, Right right)
{
	return op<composition>(std::tuple_cat(left.actions(), std::make_tuple(right)));
}

template <typename Left, typename... Right>
composition<Left, Right...>
operator>> (Left left, composition<Right...> right)
{
	return op<composition>(std::tuple_cat(std::make_tuple(left), right));
}

template <typename Left, typename Right, typename = std::enable_if_t<is_action<Left>::value && is_action<Right>::value>>
composition<Left, Right>
operator>> (Left left, Right right)
{
	return { left, right };
}

template <typename... Left, typename... Right>
composition<Right..., Left...>
operator<< (composition<Left...> left, composition<Right...> right)
{
	return op<composition>(std::tuple_cat(right.actions(), left.actions()));
}

template <typename... Left, typename Right>
composition<Right, Left...>
operator<< (composition<Left...> left, Right right)
{
	return op<composition>(std::tuple_cat(std::make_tuple(right), left.actions()));
}

template <typename Left, typename... Right>
composition<Right..., Left>
operator<< (Left left, composition<Right...> right)
{
	return op<composition>(std::tuple_cat(right, std::make_tuple(left)));
}

template <typename Left, typename Right, typename = std::enable_if_t<is_action<Left>::value && is_action<Right>::value>>
composition<Right, Left>
operator<< (Left left, Right right)
{
	return { right, left };
}

/*! Helper to unify action results.
 */
template <typename BinaryOp, typename... Left, typename... Right>
auto
operator+ (reduction<BinaryOp, Left...> left, reduction<BinaryOp, Right...> right)
{
	return op<reduction>(union_of<typename traits<nth<0, Left...>>::output>(),
		std::tuple_cat(left.actions(), right.actions()));
}

template <typename... Left, typename Right>
auto
operator+ (reduction<Left...> left, Right right)
{
	return op<reduction>(union_of<typename traits<Right>::output>(),
		std::tuple_cat(left.actions(), std::make_tuple(right)));
}

template <typename Left, typename... Right>
auto
operator+ (Left left, reduction<Right...> right)
{
	return op<reduction>(union_of<typename traits<Left>::output>(),
		std::tuple_cat(std::make_tuple(left), right));
}

template <typename Left, typename Right, typename = std::enable_if_t<is_action<Left>::value && is_action<Right>::value>>
auto
operator+ (Left left, Right right)
{
	return op<reduction>(union_of<typename traits<Left>::output>(),
		std::make_tuple(left, right));
}

template <typename BinaryOp, typename... Actions>
auto
reduce (BinaryOp bop, Actions... actions)
{
	return op<reduction>(bop, std::make_tuple(actions...));
}

/*! Helper to create an std::unique_ptr out of any action.
 */
template <typename Action>
std::unique_ptr<action::base<typename traits<Action>::input, typename traits<Action>::output>>
as_ptr (Action action)
{
	return std::make_unique<identity<Action>>(action);
}

/*! Create an action out of any function.
 */
template <typename Input, typename Output>
function<Input, Output>
then (std::function<Output(Input)> fun)
{
	return { fun };
}

/*! An action that takes nothing and produces a list of source files.
 *
 * The action is created with a list of matchers to collect sources to compile.
 */
class sources final : public virtual base<nothing, files>
{
public:
	sources (files input)
		: _input(input)
	{ }

	files
	run (nothing _)
	{
		// TODO(meh): implement this
		return _input;
	}

private:
	files _input;
};

/*! An action that takes nothing and produces a list of source files.
 *
 * The action is created with a list of matchers to collect objects to link.
 */
class objects final : public virtual base<nothing, files>
{
public:
	objects (files input)
		: _input(input)
	{ }

	files
	run (nothing _)
	{
		// TODO(meh): implement this
		return _input;
	}

private:
	files _input;
};

/*! An action that takes a list of files (source files) and produces a list of
 *  files (object files).
 *
 * In this step the input files are checked to be up-to-date with the output
 * files, and compilation is skipped if not needed.
 */
class compile final : public virtual base<files, files>
{
public:
	files
	run (files input)
	{
		// TODO(meh): implement this
		return input;
	}

	/*! Add a path to the include paths.
	 */
	compile
	include (std::string value)
	{
		_flags.push_back("-I" + value);
		return *this;
	}

	/*! Add a definition.
	 */
	compile
	define (std::string name, std::string value)
	{
		_flags.push_back("-D" + name + "=" + value);
		return *this;
	}

	/*! Enable a definition.
	 */
	compile
	define (std::string name)
	{
		_flags.push_back("-D" + name + "=1");
		return *this;
	}

	compile
	standard (std::string name)
	{
		_flags.push_back("-std=" + name);
		return *this;
	}

private:
	std::vector<std::string> _flags;
};

/*! An action that takes a list of files (object files) and produces a program.
 *
 * This is the final linking step that produces a valid provision.
 */
class executable final : public virtual base<files, program>
{
public:
	program
	run (files input)
	{
		// TODO(meh): implement this
		return { "" };
	}

	/*! Add a path to the library paths.
	 */
	executable
	include (std::string value)
	{
		_flags.push_back("-L" + value);
		return *this;
	}

	/*! Add a library to be linked.
	 */
	executable
	link (std::string name)
	{
		_flags.push_back("-l" + name);
		return *this;
	}

	/*! Add a library to be linked.
	 */
	executable
	use (std::string path)
	{
		// TODO(meh): actually link it
		return *this;
	}

private:
	std::vector<std::string> _flags;
};

/*! An action that takes a list of files (object files) and produces a shared
 *  library.
 *
 * This is the final linking step that produces a valid provision.
 */
class shared final : public virtual base<files, library>
{
public:
	library
	run (files input)
	{
		// TODO(meh): implement this
		return { false, {}, {} };
	}

	/*! Add a path to the library paths.
	 */
	shared
	include (std::string value)
	{
		_flags.push_back("-L" + value);
		return *this;
	}

	/*! Add a library to be linked.
	 */
	shared
	link (std::string name)
	{
		_flags.push_back("-l" + name);
		return *this;
	}

	/*! Add a library to be linked.
	 */
	shared
	use (std::string path)
	{
		// TODO(meh): actually link it
		return *this;
	}

private:
	std::vector<std::string> _flags;
};

/*! An action that takes a list of files (object files) and produces a static
 *  archive.
 *
 * This is the final linking step that produces a valid provision.
 */
class archive final : public virtual base<files, library>
{
public:
	library
	run (files input)
	{
		// TODO(meh): implement this
		return { true, {}, {} };
	}
};

struct none
none ()
{
	return {};
}

template <typename Type>
requirements
use (std::string path)
{
	requirements r;
	r.use<Type>(path);

	return r;
}

class sources
sources (files input)
{
	return input;
}

class objects
objects (files input)
{
	return input;
}

class compile
compile ()
{
	return {};
}

class executable
executable ()
{
	return {};
}

class shared
shared ()
{
	return {};
}

class archive
archive ()
{
	return {};
}

} }
