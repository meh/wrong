#pragma once

#include <functional>
#include <algorithm>
#include <array>
#include <numeric>

#include <wrong/provision>
#include <wrong/files>

namespace wrong { namespace action {

/*! Traits every action must define.
 */
template <typename Self>
struct traits
{
	using input = typename Self::input;
	using output = typename Self::output;
};

template <typename Input, typename Output>
struct base
{
	using input = Input;
	using output = Output;

	virtual Output run (Input input) = 0;
	virtual ~base () { }
};

/*! Nothing of value.
 */
struct nothing
{
	nothing ()
	{ }

	template <typename Input>
	nothing (Input _input)
	{ }
};

/*! An action that takes nothing and returns nothing.
 */
struct none final : public virtual base<nothing, nothing>
{
	nothing
	run (nothing input)
	{
		return {};
	}
};

/*! Trick to put an action into a pointer.
 */
template <typename Action>
class identity final
	: public virtual base<typename traits<Action>::input, typename traits<Action>::output>
{
public:
	identity (Action action)
		: _action(action)
	{ }

	typename traits<Action>::output
	run (typename traits<Action>::input input)
	{
		return _action.run(input);
	}

private:
	Action _action;
};

/*! Call the function as an action.
 *
 * What this allows is to turn a normal function into an action, making it
 * usable within the rest of the system.
 *
 * ```cpp
 * // For example, this allows the creation of conditionals.
 * sources({ "source/?.cpp" })
 * >> apply<files, files>([](auto sources) {
 *   // Checks if there's a source file named "d.cpp".
 *   if (sources.contains("source/d.cpp")) {
 *      // If so, pretend there is only one source file called "a.cpp".
 *      return { "source/a.cpp" };
 *   }
 *   else {
 *      return sources;
 *   }
 * })
 * >> compile()
 * ```
 */
template <typename Input, typename Output>
class function final : public virtual base<Input, Output>
{
public:
	function (std::function<Output(Input)> fun)
		: _fun(fun)
	{ }

	Output
	run (Input input)
	{
		return _fun(input);
	}

private:
	std::function<Output(Input)> _fun;
};

/*! Allows composition of actions.
 */
template <typename Head, typename... Tail>
class compose final
	: public virtual base<typename traits<Head>::input, typename traits<nth<sizeof...(Tail) - 1, Tail...>>::output>
{
	static_assert(sizeof...(Tail) >= 1, "unary compose makes no sense");

public:
	compose (Head head, Tail... tail)
		: _actions({ head, tail... })
	{ }

	typename traits<nth<sizeof...(Tail) - 1, Tail...>>::output
	run (typename traits<Head>::input input)
	{
		return multiply<typename traits<nth<sizeof...(Tail) - 1, Tail...>>::output,
			0, Head, Tail...>(input);
	}

	std::tuple<Head, Tail...>
	actions ()
	{
		return _actions;
	}

private:
	template <typename Output, size_t I, typename First>
	Output
	multiply (typename traits<First>::input input)
	{
		return std::get<I>(_actions).run(input);
	}

	template <typename Output, size_t I, typename First, typename Second, typename... Rest>
	Output
	multiply (typename traits<First>::input input)
	{
		return multiply<Output, I + 1, Second, Rest...>(std::get<I>(_actions).run(input));
	}

private:
	std::tuple<Head, Tail...> _actions;
};

template <typename Head, typename... Tail>
class accumulate final
	: public virtual base<typename traits<Head>::input, typename traits<Head>::output>
{
	static_assert(sizeof...(Tail) >= 1, "unary accumulate makes no sense");

	static_assert(is_all_true<std::is_same<typename traits<Head>::input, typename traits<Tail>::input>::value...>::value,
		"cannot accumulate actions of different input type");

	static_assert(is_all_true<std::is_same<typename traits<Head>::output, typename traits<Tail>::output>::value...>::value,
		"cannot accumulate actions of different output type");

public:
	accumulate (Head head, Tail... tail)
		: _actions({ head, tail... })
	{ }

	typename traits<Head>::output
	run (typename traits<Head>::input input)
	{
		return sum(input, std::index_sequence_for<Tail...>{});
	}

	std::tuple<Head, Tail...>
	actions ()
	{
		return _actions;
	}

private:
	template <size_t... I>
	typename traits<Head>::output
	sum (typename traits<Head>::input input, std::index_sequence<I...>)
	{
		return std::get<0>(_actions).run(input) + (std::get<I>(_actions).run(input) + ...);
	}

private:
	std::tuple<Head, Tail...> _actions;
};

// Helper to create operators from a tuple.
template <template <typename...> class Operator, typename... Action, size_t... Indices>
Operator<Action...>
make (std::tuple<Action...> actions, std::index_sequence<Indices...>)
{
	return { std::get<Indices>(actions)... };
}

template <template <typename...> class Operator, typename... Action, typename Indices = std::make_index_sequence<sizeof...(Action)>>
Operator<Action...>
make (std::tuple<Action...> actions)
{
	return make<Operator>(actions, Indices{});
}

/*! Helper to compose actions.
 */
template <typename... Left, typename... Right>
compose<Left..., Right...>
operator>> (compose<Left...> left, compose<Right...> right)
{
	return make<compose>(concat(left.actions(), right.actions()));
}

template <typename... Left, typename Right>
compose<Left..., Right>
operator>> (compose<Left...> left, Right right)
{
	return make<compose>(concat(left.actions(), std::make_tuple(right)));
}

template <typename Left, typename... Right>
compose<Left, Right...>
operator>> (Left left, compose<Right...> right)
{
	return make<compose>(concat(std::make_tuple(left), right));
}

template <typename Left, typename Right>
compose<Left, Right>
operator>> (Left left, Right right)
{
	return { left, right };
}

/*! Helper to accumulate actions.
 */
template <typename... Left, typename... Right>
accumulate<Left..., Right...>
operator+ (accumulate<Left...> left, accumulate<Right...> right)
{
	return make<accumulate>(concat(left.actions(), right.actions()));
}

template <typename... Left, typename Right>
accumulate<Left..., Right>
operator+ (accumulate<Left...> left, Right right)
{
	return make<accumulate>(concat(left.actions(), std::make_tuple(right)));
}

template <typename Left, typename... Right>
accumulate<Left, Right...>
operator+ (Left left, accumulate<Right...> right)
{
	return make<accumulate>(concat(std::make_tuple(left), right));
}

template <typename Left, typename Right>
accumulate<Left, Right>
operator+ (Left left, Right right)
{
	return { left, right };
}

/*! Helper to create an std::unique_ptr out of any action.
 */
template <typename Action>
std::unique_ptr<action::base<typename traits<Action>::input, typename traits<Action>::output>>
as_ptr (Action action)
{
	return std::make_unique<identity<Action>>(action);
}

/*! Create an action out of any function.
 */
template <typename Input, typename Output>
function<Input, Output>
then (std::function<Output(Input)> fun)
{
	return { fun };
}

/*! An action that takes nothing and produces a list of source files.
 *
 * The action is created with a list of matchers to collect sources to compile.
 */
struct sources final : public virtual base<nothing, files>
{
	sources (files input)
		: _input(input)
	{ }

	files
	run (nothing _)
	{
		// TODO(meh): implement this
		return _input;
	}

private:
	files _input;
};

/*! An action that takes nothing and produces a list of source files.
 *
 * The action is created with a list of matchers to collect objects to link.
 */
struct objects final : public virtual base<nothing, files>
{
	objects (files input)
		: _input(input)
	{ }

	files
	run (nothing _)
	{
		// TODO(meh): implement this
		return _input;
	}

private:
	files _input;
};

/*! An action that takes a list of files (source files) and produces a list of
 *  files (object files).
 *
 * In this step the input files are checked to be up-to-date with the output
 * files, and compilation is skipped if not needed.
 */
class compile final : public virtual base<files, files>
{
public:
	files
	run (files input)
	{
		// TODO(meh): implement this
		return input;
	}

	/*! Add a path to the include paths.
	 */
	compile
	include (std::string value)
	{
		_flags.push_back("-I" + value);
		return *this;
	}

	/*! Add a definition.
	 */
	compile
	define (std::string name, std::string value)
	{
		_flags.push_back("-D" + name + "=" + value);
		return *this;
	}

	/*! Enable a definition.
	 */
	compile
	define (std::string name)
	{
		_flags.push_back("-D" + name + "=1");
		return *this;
	}

	compile
	standard (std::string name)
	{
		_flags.push_back("-std=" + name);
		return *this;
	}

private:
	std::vector<std::string> _flags;
};

/*! An action that takes a list of files (object files) and produces a program.
 *
 * This is the final linking step that produces a valid provision.
 */
class executable final : public virtual base<files, program>
{
public:
	program
	run (files input)
	{
		// TODO(meh): implement this
		return { "" };
	}

	/*! Add a path to the library paths.
	 */
	executable
	include (std::string value)
	{
		_flags.push_back("-L" + value);
		return *this;
	}

	/*! Add a library to be linked.
	 */
	executable
	link (std::string name)
	{
		_flags.push_back("-l" + name);
		return *this;
	}

	/*! Add a library to be linked.
	 */
	executable
	use (std::string path)
	{
		// TODO(meh): actually link it
		return *this;
	}

private:
	std::vector<std::string> _flags;
};

/*! An action that takes a list of files (object files) and produces a shared
 *  library.
 *
 * This is the final linking step that produces a valid provision.
 */
class shared final : public virtual base<files, library>
{
public:
	library
	run (files input)
	{
		// TODO(meh): implement this
		return { false, {}, {} };
	}

	/*! Add a path to the library paths.
	 */
	shared
	include (std::string value)
	{
		_flags.push_back("-L" + value);
		return *this;
	}

	/*! Add a library to be linked.
	 */
	shared
	link (std::string name)
	{
		_flags.push_back("-l" + name);
		return *this;
	}

	/*! Add a library to be linked.
	 */
	shared
	use (std::string path)
	{
		// TODO(meh): actually link it
		return *this;
	}

private:
	std::vector<std::string> _flags;
};

/*! An action that takes a list of files (object files) and produces a static
 *  archive.
 *
 * This is the final linking step that produces a valid provision.
 */
class archive final : public virtual base<files, library>
{
public:
	library
	run (files input)
	{
		// TODO(meh): implement this
		return { true, {}, {} };
	}
};

struct none
none ()
{
	return {};
}

struct sources
sources (files input)
{
	return input;
}

struct objects
objects (files input)
{
	return input;
}

class compile
compile ()
{
	return {};
}

class executable
executable ()
{
	return {};
}

class shared
shared ()
{
	return {};
}

class archive
archive ()
{
	return {};
}

} }
