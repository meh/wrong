/** Copyleft (É”) meh. - http://meh.schizofreni.co
 *
 * This file is part of wrong - https://github.com/meh/wrong
 *
 * wrong is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * wrong is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#pragma once

#include <functional>
#include <numeric>

namespace wrong { namespace action {

/*! An action is essentially a function.
 */
template <typename In, typename Out>
struct action
{
	/*! The input type for the action.
	 */
	using in = In;

	/*! The output type of the action.
	 */
	using out = Out;

	/*! Executes the action with the given input and returns the given output.
	 */
	virtual Out run (In input) = 0;

	virtual ~action () { }
};

template <typename In, typename Out>
struct scope
{
	virtual
	In
	before (In in)
	{
		return in;
	}

	virtual
	Out
	after (Out out)
	{
		return out;
	}

	virtual ~scope() { };
};

/*! Check whether a type is a valid action or not.
 */
template <typename Self, typename = void>
struct is_action : std::false_type
{ };

template <typename Self>
struct is_action<Self, std::enable_if_t<
	std::is_base_of<action<typename Self::in, typename Self::out>, Self>::value>>
: std::true_type
{ };

/*! Traits every action must define.
 */
template <typename Self, typename = void>
struct traits
{ };

template <typename Self>
struct traits<Self, std::enable_if_t<is_action<Self>::value>>
{
	/*! The input type.
	 */
	using in = typename Self::in;

	/*! The output type.
	 */
	using out = typename Self::out;
};

/*! A scope is an action that can also map input and output (or do stuff).
 *
 * This is spooky, a scope is actually just three actions combined, but the
 * first and third share state.
 */
template <typename Scope, typename Action>
class scoped : public virtual action<typename traits<Action>::in, typename traits<Action>::out>
{
public:
	scoped (Scope scope, Action action)
		: _scope(scope), _action(action)
	{ }

public:
	typename traits<Action>::out
	run (typename traits<Action>::in in)
	{
		return _scope.after(_action.run(_scope.before(in)));
	}

private:
	Scope  _scope;
	Action _action;
};

/*! Nothing of value.
 */
struct nothing
{
	nothing ()
	{ }

	template <typename In>
	nothing (In _input)
	{ }
};

/*! Turn a value into an action.
 */
template <typename Value>
class unit final : public virtual action<nothing, Value>
{
public:
	unit (Value value)
		: _value(value)
	{ }

	Value
	run (nothing _)
	{
		return _value;
	}

private:
	Value _value;
};

/*! Trick to put an action into a pointer.
 */
template <typename Action>
class identity final : public virtual action<typename traits<Action>::in, typename traits<Action>::out>
{
public:
	identity (Action action)
		: _action(action)
	{ }

	typename traits<Action>::out
	run (typename traits<Action>::in input)
	{
		return _action.run(input);
	}

private:
	Action _action;
};

/*! Turn a function into an action.
 *
 * What this allows is to turn a normal function into an action, making it
 * usable within the rest of the system.
 */
template <typename In, typename Out>
class function final : public virtual action<In, Out>
{
public:
	function (std::function<Out(In)> fun)
		: _fun(fun)
	{ }

	Out
	run (In input)
	{
		return _fun(input);
	}

private:
	std::function<Out(In)> _fun;
};

/*! Turn a value into an action.
 */
template <typename Value>
unit<Value>
value (Value value)
{
	return value;
}

/*! Helper to create an std::unique_ptr out of any action.
 */
template <typename Action>
std::unique_ptr<action<typename traits<Action>::in, typename traits<Action>::out>>
as_ptr (Action action)
{
	return std::make_unique<identity<Action>>(action);
}

/*! Create an action out of any function.
 */
template <typename In, typename Out>
function<In, Out>
then (std::function<Out(In)> fun)
{
	return { fun };
}

} }
